class FileTests usingPlatform: platform testFramework: minitest = Value (
| private TestContext = minitest TestContext.
  private AsyncTestContext = minitest AsyncTestContext.
  private actors      = platform actors.
  private Exception   = platform kernel Exception.
  private NotAValue   = platform kernel NotAValue.
  private ArgumentError = platform kernel ArgumentError.
  private Vector      = platform kernel Vector.
  private Array       = platform kernel Array.
  private ObjectMirror = platform mirrors ObjectMirror.
  private errorTestMessage = 'test exception 1'.

  private FilePath    = platform files FilePath.
  private FilePattern = platform files FilePattern.
  private FileNotFoundException = platform files FileNotFoundException.

  private modulePath = (ObjectMirror reflecting: self) classMirror classDefinition filePath.
|)(
  public class BasicFileTests = TestContext (
  | private path = ((FilePath for: modulePath)
                      containingDirectory
                      containingDirectory
                      containingDirectory / 'tests' / 'files') pattern. |
  )(
    public testUtils = (
      | a b |
      a:: FilePath for: path + '/data/A'.
      assert: a exists description: path + '/data/A is expected to exist.'.
      assert: a size equals: 3656.
      assert: a lastModified <> nil description: 'file should have a last modified date'.
      b:: FilePath for: a containingDirectory pattern.
      assert: b entries size equals: 3.
    )

    public testCreateDeleteFile = (
      | f |
      f:: FilePath for: path + '/temp/A'.
      (FilePath for: (f containingDirectory pattern)) createDirectoryIfFail: [:r| assert: false ].
      deny: f exists.
      f open: #readWrite ifFail: [:r| assert: false message: 'should not happen' ].
      assert: f exists.
      f deleteFileIfFail: [:r |].
      deny: f exists.
    )

    public testCreateDeleteDirectory = (
      | f |
      f:: FilePath for: path + '/temp/A'.
      deny: f exists.
      f createDirectoryIfFail: [:r | assert: false ].
      assert: f exists.
      f deleteDirectoryIfFail: [:r |].
      deny: f exists.
    )

    public testReadWrite = (
      | f d |
      f:: FilePath for: path + '/tmp'.
      deny: f exists.
      d:: f open: #readWrite ifFail: [:r | assert: false ].

      assert: d size equals: 0.

      0 to: 255 do:[ :i|
        d buffer at: i + 1 put: i - 128.
      ].

      d write: 256 at: 0 ifFail: [:r|].
      assert: d size equals: 256.
      assert: 256  equals: (d readAt: 0 ifFail: [:r |]).

      0 to: 255 do:[ :i|
        assert: (d buffer at: i + 1) equals: i - 128.
      ].

      d close.

      f deleteFileIfFail: [:r |].
      deny: f exists.
    )

    public testPaths = (
      | f cnt |
      cnt:: 0.
      f:: FilePattern for: path + '/data/*'.
      f pathsDo: [ :p |
        assert: p exists.
        cnt:: cnt + 1.
      ].
      assert: cnt = 3.
    )

    public testMove =(
      | f g |
      f:: FilePath for: path + '/tmp'.
      f open: #readWrite ifFail: [:r|].

      f copyNamed: 'tmp2'.
      g:: FilePath for: path + '/tmp2'.
      assert: g exists.
      assert: f exists.
      assert: g size equals: f size.

      g deleteFileIfFail: [:r|].
      deny: g exists.

      f moveAs: g.
      assert: g exists.
      deny: f exists.

      g deleteFileIfFail: [:r|].
    )

    public testFileNotFound = (
      | f d |
      f:: FilePath for: path + '/nonExisting'.
      deny: f exists description: 'The file ' + f name asString + ' should not exist.'.
      d:: f open: #read ifFail: [:err |
        assert: err equals: #FileNotFound.
        #FileNotFoundSuccessfullyRetrieved ].

      assert: d equals: #FileNotFoundSuccessfullyRetrieved.

      d:: f open: #read ifFail: [:err |
        assert: err equals: #FileNotFound.
        ^ self ].

      assert: false description: 'Should not reach here because of return above.'
    )

    public testFileNotFoundException = (
      | f |
      f:: FilePath for: path + '/nonExisting'.
      deny: f exists description: 'The file ' + f name asString + ' should not exist.'.
      should: [ f open: #read ] signal: FileNotFoundException.
    )

    public testInvalidAccessMode = (
      | f |
      f:: FilePath for: path + '/nonExisting'.

      should: [ f open: #readr     ] signal: ArgumentError.
      should: [ f open: #Read      ] signal: ArgumentError.
      should: [ f open: #Write     ] signal: ArgumentError.
      should: [ f open: #ReadWrite ] signal: ArgumentError.
    )
  ) : (
    TEST_CONTEXT = ()
  )
)
